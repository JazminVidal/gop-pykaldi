import numpy as np
from IPython import embed

# Function that reads transcriptions files and loads them to
# a series of useful dictionaries

def generate_dict_from_transcripctions(transcriptions):

    trans_dict = dict()
    trans_dict_clean = dict()
    sent_dict = dict()

    # Read transcription file
    for line in open(transcriptions,'r'):

        fields = line.strip().split()

        if len(fields) <= 2:
            continue

        sent = fields[1].strip(":")

        if fields[0] == "TEXT":
            sent_dict[sent] = fields[2:]

        if fields[0] != "TRANSCRIPTION":
            continue

        if sent not in trans_dict_clean:

            # Before loading the first transcription for a sentence,
            # create an entry for it in the dict. The entry will be a
            # list of lists. One list for each possible transcription
            # for that sentence.

            trans_dict[sent] = list()
            trans_dict_clean[sent] = list()

        trans = [[]]
        for i in range(2, len(fields)):
            phones = fields[i].split("/")

            # Reproduce the transcriptions up to now as many times as
            # the number of phone variations in this slot. Then, append
            # one variation to each copy.

            trans_new = []
            for p in phones:
                for t in trans:
                    t_tmp = t + [p.strip()]
                    trans_new.append(t_tmp)
            trans = trans_new

        trans_dict[sent] += trans

    for sent, trans in trans_dict.items():
        trans_clean_new = []
        for t in trans:
            trans_clean_new.append([x for x in t if x != '0'])

        if sent not in trans_dict_clean:
            trans_dict_clean[sent] = list()

        trans_dict_clean[sent] += trans_clean_new

    return trans_dict, trans_dict_clean, sent_dict



def generate_utterance_list_from_path(sample_list_path):
    utterance_list = []
    utt_list_fh = open(sample_list_path, 'r')
    for line in utt_list_fh.readlines():
        logid = line.strip().split(' ')[0]
        utterance_list.append(logid)
    return utterance_list

def generate_utterance_list_from_glob(labels_dir):
    utterance_list = [re.sub('.TextGrid','', re.sub('.*\/','',s)) for s in glob.glob("%s/*/*"%labels_dir)]
    return utterance_list


def get_trans_auto_from_alignments(utterance, alignments):
    if utterance in alignments.index.values:
        trans_auto = alignments.loc[utterance].phones
    else:
        raise Exception("WARNING: Missing alignment for "+ utterance)
    return trans_auto

#Returns two references that best match a given transcription,
#one with zeros, one without zeros
#(A zero represents a deletion)
def find_best_ref(transcription, reference_list_zero, reference_list, spk):

    best_trans_idx = None
    best_trans_corr = 0

    for trans_idx, trans in enumerate(reference_list):
        if(len(trans) == len(transcription)):
            num_correct = np.sum([t==a for t, a in np.c_[trans,transcription]])
            if num_correct > best_trans_corr:
                best_trans_corr = num_correct
                best_trans_idx = trans_idx

    if best_trans_idx == None:
        embed()
        raise Exception("WARNING: %s does not match with transcription"%(spk))

    best_trans      = reference_list[best_trans_idx]
    best_trans_zero = reference_list_zero[best_trans_idx]

    return best_trans, best_trans_zero

#Returns path to specific labels file for a given utterance
def get_labels_file_path(labels_dir_path, utterance):
    spk, _ = utterance.split("_")
    return "%s/%s/%s/%s.txt"%(labels_dir_path, spk, "labels", utterance)

#This function reads a single reference file and returns 
#the reference column, the manual annotation and the labels column
#as lists
def get_reference(file):
    reference = []
    annot_manual = []
    labels = []
    i = 0
    for line in open(file).readlines():
        l=line.split()
        reference.append(l[1])
        annot_manual.append(l[2])
        labels.append(l[3])

        i += 1

    return reference, annot_manual, labels

def phonelist2str(phones):
    return " ".join(["%3s"%p for p in phones])

#This function returns a series of useful references and labels for the transcriptions
#generated by an aligner (for every utterance in utterance list).
def get_reference_from_system_alignments(reference_transcriptions_path, labels_dir_path, system_alignments, utterance_list):

    output = {}

    #Load reference dictionaries from reference transcriptions
    ref_dict_with_zeros, ref_dict_without_zeros, sent_dict_complete = generate_dict_from_transcripctions(reference_transcriptions_path)

    # Now, iterate over utterances
    for utterance in utterance_list:

        spk, sent = utterance.split("_")

        labels_file_path = get_labels_file_path(labels_dir_path, utterance)
        print("----------------------------------------------------------------------------------------")
        print("Speaker %s, sentence %s: %s (File: %s)"%(spk, sent, " ".join(sent_dict_complete[sent]), labels_file_path))
        
        #Get reference, manual annotation and labels from reference file 
        ref_labels, trans_manual, labels = get_reference(labels_file_path)

        trans_auto = get_trans_auto_from_alignments(utterance, system_alignments)


        # Find the reference transcription for this sentence that best matches the alignment transcription
        best_ref_auto, best_ref_auto_zero = find_best_ref(trans_auto, ref_dict_with_zeros[sent], ref_dict_without_zeros[sent], spk)

        print("BEST_REF_AUTO:        %s (chosen out of %d transcriptions)"%(phonelist2str(best_ref_auto), len(ref_dict_without_zeros[sent])))
        print("TRANS_AUTO:           "+phonelist2str(trans_auto))
        print("LABELS:               "+phonelist2str(labels))
        print("BEST_REF_AUTO_ZERO:   "+phonelist2str(best_ref_auto_zero))
        print("TRANS_MANUAL:         "+phonelist2str(trans_manual))
        print("REF_LABELS:           "+phonelist2str(ref_labels))

        output[utterance] = {
            'trans_auto'         : trans_auto, 
            'labels'             : labels, 
            'best_ref_auto_zero' : best_ref_auto_zero, 
            'best_ref_auto'      : best_ref_auto, 
            'trans_manual'       : trans_manual, 
            'ref_labels'         : ref_labels 
        }

    return output


#phone_sym2int_dict:  Dictionary mapping phone symbol to integer given a phone list path
#phone_int2sym_dict:  Dictionary mapping phone integer to symbol given a phone list path
#phone_int2node_dict: Dictionary mapping phone symbol to the index of the node in the networks's output layer
#NOTE: The node number in the output layer is not the same as the phone number, as some phones will not be scored
def get_phone_dictionaries(phone_list_path):
    #Open file that contains list of pure phones
    phones_list_fh = open(phone_list_path, "r")

    phone_sym2int_dict  = {}
    phone_int2sym_dict  = {}
    phone_int2node_dict = {}
    current_node_index  = 0
    #Populate the dictionaries
    for line in phones_list_fh.readlines():
        line = line.split()
        phone_symbol = line[0]
        phone_number = int(line[1])
        use_phone    = bool(int(line[2]))
        if use_phone:
            phone_sym2int_dict[phone_symbol]    = phone_number
            phone_int2sym_dict[phone_number]    = phone_symbol
            phone_int2node_dict[phone_number]   = current_node_index
            current_node_index += 1

    return phone_sym2int_dict, phone_int2sym_dict, phone_int2node_dict
